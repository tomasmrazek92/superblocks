{
  "version": 3,
  "sources": ["../bin/live-reload.js", "../src/utils/globalFunctions.js", "../src/blog-detail.js"],
  "sourcesContent": ["new EventSource(`${SERVE_ORIGIN}/esbuild`).addEventListener('change', () => location.reload());\n", "// #region Swipers Function\nlet windowWidth = window.innerWidth;\n\n// Create an object to hold unique counters for each classSelector.\nlet uniqueIdCounters = {};\nlet shouldInitializeImmediately = false; // Add this flag at the top of your function\n\nexport const createResponsiveSwiper = (\n  componentSelector,\n  swiperSelector,\n  classSelector,\n  options,\n  mode\n) => {\n  // Step 2: Fetch elements by their componentSelector; if none, exit the function\n  let elements = $(componentSelector);\n  if (elements.length === 0) return;\n\n  // Reset the uniqueIdCounters for this classSelector to 0\n  uniqueIdCounters[classSelector] = 0;\n\n  // Step 3: Loop through each matched element\n  uniqueIdCounters[classSelector] = uniqueIdCounters[classSelector] || 0;\n  elements.each(function () {\n    // Generate a unique key for this instance based on the classSelector and a counter\n    let uniqueKey = `${classSelector}_${uniqueIdCounters[classSelector]}`;\n\n    // Step 4: Add unique classes to swiper container, arrows and pagination for this instance\n    addUniqueClassesToElements(this, swiperSelector, uniqueKey, [\n      '[swiper-arrow]',\n      '.swiper-navigation',\n    ]);\n\n    // Step 5: Merge default and passed swiper options\n    let swiperOptions = getMergedSwiperOptions(options, uniqueKey);\n\n    // Step 6: Initialize or destroy swipers based on media query and passed mode\n    manageSwiperInstance(this, swiperSelector, uniqueKey, classSelector, swiperOptions, mode);\n\n    // Increment unique ID counter for the specific classSelector\n    uniqueIdCounters[classSelector]++;\n  });\n};\n\n// Adds unique classes to swiper and control elements\nconst addUniqueClassesToElements = (context, swiperSelector, uniqueKey, controlSelectors) => {\n  controlSelectors.forEach((selector) => {\n    $(context).find(selector).addClass(uniqueKey);\n  });\n  $(context).find(swiperSelector).addClass(uniqueKey);\n};\n\n// Merge default and custom swiper options\nconst getMergedSwiperOptions = (options, uniqueKey) => {\n  return Object.assign({}, options, {\n    navigation: {\n      prevEl: `[swiper-arrow=\"prev\"].${uniqueKey}`,\n      nextEl: `[swiper-arrow=\"next\"].${uniqueKey}`,\n    },\n    pagination: {\n      el: `.swiper-navigation.${uniqueKey}`,\n      type: 'bullets',\n      bulletActiveClass: 'active',\n      bulletClass: 'swiper-bullet',\n      clickable: true,\n      renderBullet: function (index, className) {\n        return '<span class=\"' + className + '\">' + '<b></b>' + '</span>';\n      },\n    },\n  });\n};\n\n// This function manages Swiper instances: initializing or destroying them based on certain conditions\nconst manageSwiperInstance = (\n  context,\n  swiperSelector,\n  uniqueKey,\n  classSelector,\n  swiperOptions,\n  mode\n) => {\n  // Initialize the nested object for storing Swiper instances if it doesn't exist\n  swipers[classSelector] = swipers[classSelector] || {};\n  swipers[classSelector][uniqueKey] = swipers[classSelector][uniqueKey] || {};\n\n  // Fetch the existing Swiper instance information, if it exists\n  let existingInstance = swipers[classSelector][uniqueKey];\n  let existingSwiper = existingInstance.swiperInstance;\n\n  // Determine under what conditions the Swiper should be initialized for desktop and mobile\n  let shouldInitDesktop = mode === 'desktop' && window.matchMedia('(min-width: 992px)').matches;\n  let shouldInitMobile =\n    mode === 'mobile' && window.matchMedia('(min-width: 0px) and (max-width: 991px)').matches;\n  let shouldInitAll = mode === 'all';\n\n  // Destroy function\n  const destroySwiper = () => {\n    if (existingInstance.observer) {\n      existingInstance.observer.disconnect();\n      delete existingInstance.observer;\n    }\n    if (existingSwiper) {\n      existingSwiper.destroy(true, true);\n      delete swipers[classSelector][uniqueKey];\n    }\n  };\n\n  // Reinitialize function\n  const reInitObserver = () => {\n    // Disconnect any existing observers\n    if (existingInstance.observer) {\n      existingInstance.observer.disconnect();\n    }\n\n    const swiperElement = $(`${swiperSelector}.${uniqueKey}`)[0];\n    const observer = new IntersectionObserver((entries) => {\n      entries.forEach((entry) => {\n        if (entry.isIntersecting && (shouldInitDesktop || shouldInitMobile || shouldInitAll)) {\n          if (!existingSwiper) {\n            let swiper = new Swiper(`${swiperSelector}.${uniqueKey}`, swiperOptions);\n            swipers[classSelector][uniqueKey] = {\n              swiperInstance: swiper,\n              mode: shouldInitDesktop ? 'desktop' : shouldInitMobile ? 'mobile' : 'all',\n              initialized: true,\n            };\n            observer.disconnect();\n          }\n        }\n      });\n    }, {});\n\n    // Store the observer instance\n    swipers[classSelector][uniqueKey].observer = observer;\n\n    // Observe the element\n    observer.observe(swiperElement);\n  };\n\n  // Check the conditions and either destroy or reinitialize\n  if (!shouldInitDesktop && mode === 'desktop') destroySwiper();\n  else if (!shouldInitMobile && mode === 'mobile') destroySwiper();\n  else if (!shouldInitAll && mode === 'all') destroySwiper();\n  else if ((shouldInitDesktop || shouldInitMobile || shouldInitAll) && !existingSwiper) {\n    reInitObserver();\n  }\n};\n\n// Function to initialize swipers from an array of instances\nexport const runSwipers = (swiperInstances) => {\n  swiperInstances.forEach((instance) => {\n    createResponsiveSwiper(...instance);\n  });\n};\n\nexport const initSwipers = (swiperInstances, swipersState) => {\n  // Load\n  runSwipers(swiperInstances);\n\n  // Resize\n  window.addEventListener('resize', function () {\n    if (window.innerWidth !== windowWidth) {\n      windowWidth = window.innerWidth;\n      runSwipers(swiperInstances);\n    }\n  });\n};\n\n//#endregion\n\nexport function copyUrl() {\n  // Paste here\n  var $temp = $('<input>');\n  var $url = $(location).attr('href');\n  var label = $('#copyUrl_label');\n  let timeOut;\n\n  // Click\n  $('#copyUrl').click(function () {\n    $('body').append($temp);\n    $temp.val($url).select();\n    document.execCommand('copy');\n    $temp.remove();\n\n    clearTimeout(timeOut); // Corrected the function name and variable consistency\n    label.hide();\n    label.fadeIn();\n    timeOut = setTimeout(() => {\n      // Corrected the function name and fixed variable naming consistency\n      label.fadeOut();\n    }, 2000);\n  });\n}\n", "import { copyUrl } from './utils/globalFunctions';\n\n$(document).ready(function () {\n  // Top Author\n  if ($('.blog-detail_author-item').length === 1) {\n    $('#authors-name').text($('.blog-detail_author-item').attr('data-tippy-content'));\n  } else if ($('.blog-detail_author-item').length > 5) {\n    $('[author-count]').css('display', 'flex');\n    $('[author-count]').text(function () {\n      var count = $('.blog-detail_author-item').length - 5;\n      return count > 0 ? '+' + count : count;\n    });\n\n    tippy('[data-tippy-content]', {\n      arrow: true,\n      animation: 'fade',\n      interactive: true,\n    });\n  }\n\n  // Blog Card Authors\n  $('.blog-index_item').each(function () {\n    let authors = $(this).find('.blog-index_item-authors-item');\n    if (authors.length === 0) {\n      $(this).find('.blog-index_item-author-box').hide();\n      $(this).find('[authors-name-box]').hide();\n      $(this).find('.blog-index_item-line').hide();\n    } else if (authors.length === 1) {\n      $(this).find('[authors-name]').text(authors.find('img').attr('alt'));\n    } else if (authors.length > 1) {\n      let counter = $(this).find('.blog-index_item-authors-img.counter');\n      counter.css('display', 'flex');\n      counter.text(function () {\n        var count = authors.length - 1;\n        return count > 0 ? '+' + count : count;\n      });\n    }\n  });\n\n  // Copy URL\n  copyUrl();\n});\n"],
  "mappings": ";;;AAAA,MAAI,YAAY,GAAG,iCAAsB,EAAE,iBAAiB,UAAU,MAAM,SAAS,OAAO,CAAC;;;ACC7F,MAAI,cAAc,OAAO;AAwKlB,WAAS,UAAU;AAExB,QAAI,QAAQ,EAAE,SAAS;AACvB,QAAI,OAAO,EAAE,QAAQ,EAAE,KAAK,MAAM;AAClC,QAAI,QAAQ,EAAE,gBAAgB;AAC9B,QAAI;AAGJ,MAAE,UAAU,EAAE,MAAM,WAAY;AAC9B,QAAE,MAAM,EAAE,OAAO,KAAK;AACtB,YAAM,IAAI,IAAI,EAAE,OAAO;AACvB,eAAS,YAAY,MAAM;AAC3B,YAAM,OAAO;AAEb,mBAAa,OAAO;AACpB,YAAM,KAAK;AACX,YAAM,OAAO;AACb,gBAAU,WAAW,MAAM;AAEzB,cAAM,QAAQ;AAAA,MAChB,GAAG,GAAI;AAAA,IACT,CAAC;AAAA,EACH;;;AC7LA,IAAE,QAAQ,EAAE,MAAM,WAAY;AAE5B,QAAI,EAAE,0BAA0B,EAAE,WAAW,GAAG;AAC9C,QAAE,eAAe,EAAE,KAAK,EAAE,0BAA0B,EAAE,KAAK,oBAAoB,CAAC;AAAA,IAClF,WAAW,EAAE,0BAA0B,EAAE,SAAS,GAAG;AACnD,QAAE,gBAAgB,EAAE,IAAI,WAAW,MAAM;AACzC,QAAE,gBAAgB,EAAE,KAAK,WAAY;AACnC,YAAI,QAAQ,EAAE,0BAA0B,EAAE,SAAS;AACnD,eAAO,QAAQ,IAAI,MAAM,QAAQ;AAAA,MACnC,CAAC;AAED,YAAM,wBAAwB;AAAA,QAC5B,OAAO;AAAA,QACP,WAAW;AAAA,QACX,aAAa;AAAA,MACf,CAAC;AAAA,IACH;AAGA,MAAE,kBAAkB,EAAE,KAAK,WAAY;AACrC,UAAI,UAAU,EAAE,IAAI,EAAE,KAAK,+BAA+B;AAC1D,UAAI,QAAQ,WAAW,GAAG;AACxB,UAAE,IAAI,EAAE,KAAK,6BAA6B,EAAE,KAAK;AACjD,UAAE,IAAI,EAAE,KAAK,oBAAoB,EAAE,KAAK;AACxC,UAAE,IAAI,EAAE,KAAK,uBAAuB,EAAE,KAAK;AAAA,MAC7C,WAAW,QAAQ,WAAW,GAAG;AAC/B,UAAE,IAAI,EAAE,KAAK,gBAAgB,EAAE,KAAK,QAAQ,KAAK,KAAK,EAAE,KAAK,KAAK,CAAC;AAAA,MACrE,WAAW,QAAQ,SAAS,GAAG;AAC7B,YAAI,UAAU,EAAE,IAAI,EAAE,KAAK,sCAAsC;AACjE,gBAAQ,IAAI,WAAW,MAAM;AAC7B,gBAAQ,KAAK,WAAY;AACvB,cAAI,QAAQ,QAAQ,SAAS;AAC7B,iBAAO,QAAQ,IAAI,MAAM,QAAQ;AAAA,QACnC,CAAC;AAAA,MACH;AAAA,IACF,CAAC;AAGD,YAAQ;AAAA,EACV,CAAC;",
  "names": []
}
